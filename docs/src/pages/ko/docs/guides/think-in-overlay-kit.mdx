# overlay-kit으로 생각하기

`overlay-kit`은 React 애플리케이션에서 오버레이(모달, 팝업, 다이얼로그 등)를 간결하고 선언적으로 관리하기 위한 라이브러리입니다.

이 문서는 `overlay-kit`을 효과적으로 사용하는 사고방식과 설계 패턴을 제시합니다.
React의 철학과 Declarative Overlay Pattern에 기반하여, 상태 관리의 복잡성을 줄이고 생산성을 높이는 방법을 소개합니다.

상태 관리 코드 제거되었으며, 오버레이 동작을 선언적으로 정의하고 있습니다.

## Declarative Overlay Pattern

overlay-kit은 React의 선언적 UI 철학을 오버레이 관리에 확장한 Declarative Overlay Pattern을 도입합니다.

이 패턴은 상태 관리와 이벤트 핸들링의 복잡성을 제거하고, 오버레이의 UI와 동작을 선언적으로 정의하는 새로운 접근 방식입니다.

### 왜 선언적 패턴이 필요한가?

기존의 오버레이 관리 방식은 **명령형(Imperative)** 접근에 의존합니다. `useState`와 같은 상태 관리 로직과 이벤트 핸들링이 섞여 있어 코드가 복잡하고 가독성이 떨어집니다.

#### 기존 명령형 접근 방식의 문제점

1. **상태 관리의 복잡성**: 열림/닫힘 상태를 직접 관리해야 하며 상태가 여러 컴포넌트에 퍼질 수 있습니다.
2. **이벤트 핸들링의 반복**: 열기, 닫기, 결과 반환 등의 이벤트 핸들링 로직이 반복됩니다.
3. **가독성 저하**: UI 코드와 상태 관리 코드가 섞여 있어 코드를 이해하기 어렵습니다.

### Declarative Overlay Pattern의 접근 방식

Declarative Overlay Pattern은 오버레이를 **상태가 아닌 동작(Behavior)** 중심으로 관리합니다. 이 패턴은 다음과 같은 핵심 원리를 따릅니다:

1. **선언적 정의**
   오버레이 UI와 동작을 **함수 호출**을 통해 선언적으로 정의합니다.
   상태를 직접 관리하지 않고 `overlay.open`이나 `overlay.openAsync`와 같은 API를 사용해 오버레이의 열림/닫힘과 동작을 선언적으로 기술합니다.

2. **상태 관리 캡슐화**
   상태 관리와 이벤트 핸들링은 `overlay-kit` 내부에서 처리되므로 개발자는 상태 관리 로직을 작성할 필요가 없습니다.
   코드의 **복잡성**이 크게 줄어들고, UI와 동작을 분리할 수 있습니다.

3. **유연한 데이터 흐름**
   Promise 기반의 `overlay.openAsync` API를 통해 오버레이 동작 결과를 비동기적으로 처리할 수 있습니다.
   이를 통해 사용자 입력이나 오버레이의 결과를 자연스럽게 체이닝하거나 비동기 로직에 결합할 수 있습니다.

#### 명령형 접근 방식

```tsx
const [isOpen, setIsOpen] = useState(false);

function handleOpen() {
  setIsOpen(true);
}

function handleClose(result) {
  console.log(result);
  setIsOpen(false);
}

return (
  <>
    <Button onClick={handleOpen}>열기</Button>
    <Dialog open={isOpen} onClose={() => handleClose('닫힘')}>
      <DialogTitle>명령형 오버레이</DialogTitle>
      <DialogActions>
        <Button onClick={() => handleClose('확인')}>확인</Button>
        <Button onClick={() => handleClose('취소')}>취소</Button>
      </DialogActions>
    </Dialog>
  </>
);
```

#### Declarative Overlay Pattern

```tsx
import { overlay } from 'overlay-kit';

function handleOverlay() {
  overlay.open(({ isOpen, close }) => (
    <Dialog open={isOpen} onClose={() => close('닫힘')}>
      <DialogTitle>선언적 오버레이</DialogTitle>
      <DialogActions>
        <Button onClick={() => close('확인')}>확인</Button>
        <Button onClick={() => close('취소')}>취소</Button>
      </DialogActions>
    </Dialog>
  ));
}
```

**핵심 차이점:**

- **명령형**: 상태를 수동으로 관리하며 이벤트 핸들링 코드가 추가됨.
- **선언적**: `overlay.open` 호출만으로 오버레이 UI와 동작을 선언적으로 정의.

#### Promise 기반의 오버레이 관리

오버레이의 결과를 비동기로 받아서 처리해야 할 수 있습니다. 이는 사용자 입력이나 작업 확인과 같은 시나리오에서 매우 유용합니다.

`overlay.openAsync`를 사용하면 오버레이의 결과를 Promise로 반환받을 수 있습니다.

```tsx
const result = await overlay.openAsync<boolean>(({ isOpen, close }) => (
  <Dialog open={isOpen} onClose={() => close(false)}>
    <DialogTitle>계속 진행하시겠습니까?</DialogTitle>
    <DialogActions>
      <Button onClick={() => close(true)}>네</Button>
      <Button onClick={() => close(false)}>아니요</Button>
    </DialogActions>
  </Dialog>
));

if (result) {
  console.log("사용자가 '네'를 선택했습니다.");
} else {
  console.log("사용자가 '아니요'를 선택했습니다.");
}
```

**장점**:

- 상태와 이벤트 핸들링 없이 결과만 반환받아 **비동기 로직**과 자연스럽게 결합할 수 있습니다.
- 코드가 간결해지고 동작이 명확해집니다.

## 작고 간단한 API

overlay-kit의 목표는 가능한 작게 유지하여 배우기 쉽게 만드는 것입니다. 따라서 overlay-kit은 너무 많은 API를 제공하고 싶지 않습니다.
범용적인 JavaScript 패턴을 바탕으로 가능한 범용적인 API를 작게 제공하려 합니다.

overlay-kit의 핵심 기능은 두 가지로 요약될 수 있습니다.

1. `overlay.open`
2. `overlay.openAsync`

overlay-kit은 이외의 더 많은 API를 늘리는 것이 아닌 JavaScript 패턴을 이용하여 다양한 오버레이를 구현하는 것을 목표로 합니다.
예를 들어, `overlay.openAsync`는 Promise 값을 반환함으로서 Promise를 활용하는 다양한 패턴을 적용할 수 있습니다.

## 가독성과 메모리 관리의 신중함

**overlay-kit**은 **가독성과 메모리 관리의 신중함**을 고려합니다.

오버레이를 닫고 다시 열 때 성능 저하가 발생할 수 있는 **복잡한 초기화 작업**이나 **대규모 데이터 처리**를 고려해야 합니다.
이를 위해 `overlay-kit`은 메모리 관리와 가독성을 모두 챙길 수 있는 설계를 제공합니다.

> **신중한 메모리 관리가 중요한 이유**
>
> 오버레이가 복잡한 데이터를 처리하거나 무거운 작업을 수행할 경우, 불필요하게 남아 있는 데이터는 성능 저하나 메모리 누수를 일으킬 수 있습니다.
>
> 이러한 상황을 라이브러리가 자동으로 판단하기는 어렵기 때문에 overlay-kit은 사용자가 직접 메모리 관리를 할 수 있도록 API를 제공합니다.

### close와 unmount의 역할

**overlay-kit**은 오버레이 관리에 두 가지 주요 함수를 제공합니다:

- **`close`**: 오버레이를 닫고 상태를 메모리에 유지합니다. 다시 열 때 초기화 비용이 줄어들어 성능을 개선합니다.
- **`unmount`**: 오버레이를 메모리에서 완전히 제거합니다. 메모리 누수를 방지하고 불필요한 데이터 유지를 최소화합니다.

### close와 unmount를 함께 사용해야 하는 이유

`unmount` 함수만 단독으로 호출하면 **닫기 애니메이션**이 실행되지 않을 수 있습니다.
따라서 닫기 애니메이션을 노출한 후 메모리에서 오버레이를 제거하려면 `close`와 `unmount`를 함께 사용하는 것이 좋습니다.

### 예제: 닫기 애니메이션 후 메모리 제거

```tsx
overlay.open(({ isOpen, close, unmount }) => (
  <Dialog open={isOpen}>
    <DialogTitle>메모리 관리</DialogTitle>
    <DialogActions>
      <Button onClick={close}>닫기</Button>
      <Button
        onClick={() => {
          close();
          unmount();
        }}
      >
        닫고 제거
      </Button>
    </DialogActions>
  </Dialog>
));
```
